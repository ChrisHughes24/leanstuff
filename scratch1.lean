import data.real.basic tactic.norm_num data.set.basic tactic.ring
open nat real
noncomputable theory
local attribute [instance, priority 0] classical.prop_decidable

lemma lim_eq_iff_const_equiv (f : cau_seq ℝ abs) (x : ℝ) : lim f = x ↔ f ≈ cau_seq.const abs x := begin
  split, have := equiv_lim f,assume h,rwa ←h,
  assume h,have := equiv_lim f,have := setoid.trans (setoid.symm this) h,rwa cau_seq.const_equiv at this,
end

lemma q_3 (S : set ℝ) : S ≠ ∅ → (∃ x, ∀ y ∈ S, y ≤ x) → ∃ f : cau_seq ℝ abs, lim f = Sup S ∧ ∀ x, f x ∈ S := begin
  assume hS b,
  cases set.exists_mem_of_ne_empty hS with x xs,
  have : ∀ ε : ℝ, ε > 0 → ∃ y ∈ S, abs (Sup S - y) < ε,
    assume ε ε0,
    apply by_contradiction,rw not_exists,
    assume hy,
    have : ∀ y : ℝ, y ∈ S → y ≤ Sup S - ε,
      assume y hy', have := hy y,rw not_exists at this,
      have := le_of_not_gt (this hy'),rwa [abs_of_nonneg,le_sub] at this,
      rw (by simp : ∀ x y : ℝ, x ≥ y ↔ y ≤ x),rw sub_nonneg,
      refine le_Sup _ b hy',
    have := (Sup_le S ⟨x, xs⟩ b).mpr this,
    rw [le_sub,sub_self] at this,
    exact not_le_of_gt ε0 this,
  generalize hf : (λ n, classical.some (this (succ n)⁻¹ (begin refine inv_pos _,rw [←nat.cast_zero,nat.cast_lt],exact dec_trivial, end))) = f,
  have hf₁ := λ n, classical.some_spec (this (succ n)⁻¹ (begin refine inv_pos _,rw [←nat.cast_zero,nat.cast_lt],exact dec_trivial, end)),
  have : is_cau_seq abs f,
    assume ε ε0,cases exists_nat_gt ((ε/2)⁻¹) with i hi,
    existsi i,assume j ji,
    have : ∀ n : ℕ, abs (Sup S - f n) < (succ n)⁻¹,assume n,
    have fn := classical.some_spec (this (succ n)⁻¹ _),rw ←hf,
      cases fn with hfn hfn₁,exact hfn₁,
    refine lt_of_le_of_lt (abs_sub_le _ (Sup S) _) _,
    rw (by ring : ε = ε /2 + ε / 2),
    have i_pos : 0 < (i : ℝ),
    refine lt_trans _ hi,refine inv_pos _,refine div_pos _ _, exact ε0, {norm_num},
    have hi₁ := (inv_lt _ _).mpr hi,
    refine add_lt_add _ _,
    refine lt_of_le_of_lt _ hi₁,rw abs_sub,
    refine le_trans (le_of_lt (this _)) _,rw inv_le_inv,rw nat.cast_le,
    exact le_succ_of_le ji,rw [←nat.cast_zero,nat.cast_lt],exact succ_pos _,
    exact i_pos,
    refine lt_of_le_of_lt _ hi₁,
    refine le_trans (le_of_lt (this _)) _,rw inv_le_inv,rw nat.cast_le,exact le_succ _,
    rw [←nat.cast_zero,nat.cast_lt], exact succ_pos _,
    exact i_pos, exact i_pos,refine div_pos ε0 (by norm_num),
  existsi (⟨f, this⟩ : cau_seq ℝ abs),rw lim_eq_iff_const_equiv,
  split,assume ε ε0,simp,
  cases exists_nat_gt (ε⁻¹) with i hi,
  existsi i,assume j ji,have := hf₁ j,
  cases this with hiS hiε,rw ←hf,simp,simp at hiε,rw ←abs_neg,simp,
  refine lt_of_lt_of_le hiε _,
  rw inv_le,refine le_of_lt (lt_of_lt_of_le hi _),rw [←nat.cast_one,←nat.cast_add,nat.cast_le,add_comm],
  exact le_succ_of_le ji,
  refine add_pos_of_pos_of_nonneg _ _,norm_num,exact ε0,
  assume x, have :=hf₁ x,cases this with this l,
  rw ←hf,simpa,
end

lemma q_4 (S : set ℝ) (u : ℝ) : S ≠ ∅ → (∀ x ∈ S, x ≤ u) → (u = Sup S ↔ ∃ f : cau_seq ℝ abs, lim f = u ∧ ∀ x, f.val x ∈ S) := begin
  assume e hu,split,assume hw,rw hw,exact q_3 _ e ⟨u,hu⟩,
  assume f, cases f with f hf,rw lim_eq_iff_const_equiv at hf,
  apply by_contradiction,
  have := (Sup_le S (set.exists_mem_of_ne_empty e) ⟨u,hu⟩).mpr hu,assume h,
  cases lt_or_eq_of_le this with uS uS,
  rw ←sub_pos at uS,
  cases hf.left (u - Sup S) uS with i hi,
  replace hi := hi i (le_refl _),simp at hi,
  have : f i ∈ S:= hf.right i,
  have := le_Sup S ⟨u,hu⟩ this,
  have : u + -Sup S ≤ abs (-u + f i),
    rw ←abs_neg,refine le_trans _ (le_abs_self _),
    simp,rw ←sub_nonneg at this,exact this,
  exact not_lt_of_ge this hi,
  exact h uS.symm,
end